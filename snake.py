# CSCI 4478 - Dr Vahid Behzadan
# Name: game.py
# Description: Classes to run a game of snake
# Reference: https://www.youtube.com/watch?v=CD4qAhfFuLo&t=1734s
# Reference: https://pastebin.com/embed_js/jB6k06hG
# Revision: 4/22/2021

import tkinter as tk
from tkinter import messagebox
from snake_state import SnakeState
from cube import *

from screen import *




class Snake(object):
    body = []
    turns = {}

    def __init__(self, color, pos, apples):
        self.color = color
        self.head = cube(pos)
        self.body.append(self.head)
        self.dirnx = 0
        self.dirny = 1

        self.walls = []
        self.walls.append(self.head)
        self.score = 0
        self.obstacles = []
        self.tmpFood = cube((0, 0), color=GREEN)
        self.next_move = "LEFT"

        self.apples = apples
        self._apple_index = 0
        self.num_of_apples = WINDOW_SIZE if not apples else len(apples)
        self._out_of_apples = False

        self.add_tail = False

    def set_obstacles(self, obstacle_pos):
        obstacle = []
        for tup in obstacle_pos:
            obstacle.append(cube(tup, color=(255, 255, 255)))
        self.obstacles = obstacle

    def move(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()

            keys = pygame.key.get_pressed()

            for key in keys:
                # print("Head position:", self.head.pos) # lets us see grid pos for head
                action = None
                if keys[pygame.K_LEFT]:
                    action = "LEFT"

                elif keys[pygame.K_RIGHT]:
                    action = "RIGHT"

                elif keys[pygame.K_UP]:
                    action = "UP"

                elif keys[pygame.K_DOWN]:
                    action = "DOWN"
                if action:
                    self.next_move = action

        self.moveAuto(self.next_move)

    def moveAuto(self, key):  # use this move method when directions are generated by successor method
        # todo: feed only actions into moveAuto - successors will have state, action, cost
        if not key:
            return 0
        last_dir_x = self.dirnx
        last_dir_y = self.dirny
        dir_x = 0
        dir_y = 0
        if key == "LEFT":
            dir_x = -1
            dir_y = 0

        elif key == "RIGHT":
            dir_x = 1
            dir_y = 0

        elif key == "UP":
            dir_x = 0
            dir_y = -1

        elif key == "DOWN":
            dir_x = 0
            dir_y = 1

        tmp_pos = self.head.pos
        if len(self.body) > 1 and (tmp_pos[0] + dir_x, tmp_pos[1] + dir_y) == self.body[1].pos:
            self.dirnx = last_dir_x
            self.dirny = last_dir_y
        else:
            self.dirnx = dir_x
            self.dirny = dir_y
        new_pos = (tmp_pos[0] + self.dirnx, tmp_pos[1] + self.dirny)
        self.head.move(self.dirnx, self.dirny)
        for cell in self.body[1:]:
            other_tmp = cell.pos
            cell.pos = tmp_pos
            tmp_pos = other_tmp
        if self.add_tail:
            tail = cube(tmp_pos)
            self.body.append(tail)
            self.add_tail = False

        # rewards for QLearning
        if self.is_terminated():  # if done
            return -10
        elif self.isGoalState(self.head.pos):
            return 1
        else:
            return 0
        # exit()

    def reset(self, pos):
        self.head = cube(pos)
        self.body = []
        self.body.append(self.head)
        self.turns = {}
        self.dirnx = 0
        self.dirny = 1

        self.walls = self.body
        self.score = 0

        self._apple_index = 0
        self._out_of_apples = False

    def addCube(self):
        self.add_tail = True

    def draw(self, surface):
        for i, c in enumerate(self.body):
            if i == 0:
                c.draw(surface, True)
            else:
                c.draw(surface)

    def update_apples(self, apples):
        self.apples = apples
        self.num_of_apples = len(apples)

    def isGoalState(self, current_pos):
        if current_pos == self.tmpFood.pos:
            # print("Goal state!")
            return True
        else:
            return False

    def getStartState(self):
        return SnakeState(self)

    def is_terminated(self):
        if self._out_of_apples:
            return True
        all_block_list = [snk.pos for snk in self.body]
        all_block_list += [obs.pos for obs in self.obstacles]
        return len(all_block_list) != len(set(all_block_list))

    def gen_new_food(self, new_pos=None):
        if self.apples:
            pos = self.apples[self._apple_index]
            self.tmpFood.reset(pos, color=GREEN)
            self._apple_index += 1
            if self._apple_index >= self.num_of_apples:
                self._out_of_apples = True
        else:
            if new_pos:
                self.tmpFood.reset(new_pos, color=GREEN)
            else:
                random_position = randomSnack(GRID_SIZE, self)
                if not random_position:  # if board is full
                    self._out_of_apples = True
                else:
                    self.tmpFood.reset(random_position, color=GREEN)

    def get_new_position(self, action):
        dirnx = 0
        dirny = 0
        if action == "LEFT":
            dirnx += -1
        elif action == "RIGHT":
            dirnx += 1
        elif action == "UP":
            dirny += -1
        elif action == "DOWN":
            dirny += 1
        new_pos = ((self.head.pos[0] + dirnx), (self.head.pos[1] + dirny))
        return new_pos

    def will_terminate(self, new_pos):
        wall_positions = []
        for x, wall in enumerate(self.walls):
            wall_positions.append(wall.pos)
        for x, obs in enumerate(self.obstacles):
            wall_positions.append(obs.pos)
        return new_pos in wall_positions


def message_box(subject, content):
    root = tk.Tk()
    root.attributes("-topmost", True)
    root.withdraw()
    messagebox.showinfo(subject, content)
    try:
        root.destroy()
    except:
        pass





